import { BlueprintParserUtils } from "../parser/blueprint-parser-utils";
import { CustomProperty, PinCategory, PinDirection, PinLink } from "./custom-property";
import { NodeClass } from "./node-class";

export class PinProperty extends CustomProperty {

    node: NodeClass;

    pinID: string;
    pinName: string;
    pinFriendlyName: string;
    pinCategory: PinCategory;
    direction: PinDirection;
    pinToolTip: string;
    pinSubCategory: string;
    pinSubCategoryObject: string;
    pinSubCategoryMemberReference: string;
    containerType: string;
    isReference: boolean;
    isConst: boolean;
    isWeakPointer: boolean;
    isUObjectWrapper: boolean;
    defaultValue: string;
    autogeneratedDefaultValue: string;
    linkedTo: PinLink[];
    persistentGUID: string;
    hidden: boolean;
    notConnectable: boolean;
    defaultValueIsReadOnly: boolean;
    defaultValueIsIgnored: boolean;
    advancedView: boolean;
    ophanedPin: boolean;

    constructor(nodeClass: NodeClass) {
        super();
        this.node = nodeClass;
    }

    getPinName() {
        if (this.pinFriendlyName !== undefined && this.pinFriendlyName.length != 0)
            return this.pinFriendlyName;
        
        return this.pinName;
    }

    parse(propertyData: string) {
        let data = propertyData.split(/,(?![^(]*\))/g);
        let key: string;
        let value: string;

        for (let i = 0; i < data.length; ++i) {
            let attribute = data[i].split('=');
            key = attribute[0];
            value = attribute[1];

            switch (key) {
                case "PinId": this.pinID = value; break;
                case "PinName": this.pinName = BlueprintParserUtils.parseString(value); break;
                case "PinFriendlyName": this.pinFriendlyName = this.parsePinFriendlyName(value); break;
                case "PinType.PinCategory": this.pinCategory = this.parsePinCategory(value); break;
                case "Direction": this.direction = this.parseDirection(value); break;
                case "PinToolTip": this.pinToolTip = BlueprintParserUtils.parseString(value); break;
                case "PinType.PinSubCategory": this.pinSubCategory = BlueprintParserUtils.parseString(value); break;
                case "PinType.PinSubCategoryObject": this.pinSubCategoryObject = this.parseSubCategoryObject(value); break;
                case "PinType.bIsReference": this.isReference = value == "True"; break;
                case "PinType.bIsConst": this.isConst = value == "True"; break;
                case "PinType.bIsWeakPointer": this.isWeakPointer = value == "True"; break;
                case "PinType.bIsUObjectWrapper": this.isUObjectWrapper = value == "True"; break;
                case "DefaultValue": this.defaultValue = BlueprintParserUtils.parseString(value); break;
                case "AutogeneratedDefaultValue": this.autogeneratedDefaultValue = BlueprintParserUtils.parseString(value); break;
                case "LinkedTo": this.linkedTo = this.parseLinkedTo(value); break;

            }
        }

    }

    parseLinkedTo(value: string): PinLink[] {
        let links = [];
        value = value.substr(1, value.length - 1);
    
        let data = value.split(',')
        for (let i = 0; i < data.length; ++i) {
            let dataset = data[i].split(' ');
            if (dataset.length == 2) {
                let link = new PinLink();
                link.nodeName = dataset[0];
                link.pinID = dataset[1];

                links.push(link);
            }
        }

        return links;
    }


    parseSubCategoryObject(value: string): string {
        let obj = value;
        let matches = value.matchAll(/'"(.*)"'/g);
        if (matches) {
            let match = matches.next();

            if (match && match.value) {
                obj = match.value[1];
            }
        }

        return obj;
    }

    parsePinFriendlyName(value: string): string {
        let name:string = "";
        
        
        if (value.startsWith("NSLOCTEXT")) {
            let prefixLength = 'NSLOCTEXT('.length - 1;
            value = value.substr(prefixLength, value.length - prefixLength - 1);

            let params = value.split(',');
            name = params[params.length - 1].replace(/"/g, '');
            return name;
        }

        name = value.replace(/"/g, '');
        
        return name;
    }

    parsePinCategory(value: string): PinCategory {
        value = BlueprintParserUtils.parseString(value);
        switch (value) {
            case "exec": return PinCategory.exec;
            case "object": return PinCategory.object;
            case "int": return PinCategory.int;
            case "float": return PinCategory.float;
            case "struct": return PinCategory.struct;
            case "bool": return PinCategory.bool;
            case "delegate": return PinCategory.delegate;
            case "name": return PinCategory.name;
        }
    }

    parseDirection(value: string): PinDirection {
        value = value.replace(/"/g, '');

        switch (value) {
            case "EGPD_Output": return PinDirection.EGPD_Output;
            case "EGPD_Input":
            default:
                return PinDirection.EGPD_Input;
        }
    }

    get isHidden(): boolean {
        if (this.node === NodeClass.CALL_FUNCTION) {
            return this.pinName === "self" && (this.linkedTo == undefined || this.linkedTo.length == 0);
        }

        return false;
    }

    get isKnotPin(): boolean {
        return this.node === NodeClass.KNOT;
    }

    get isExecutionPin(): boolean {
        return this.pinCategory === PinCategory.exec;
    }

    get isDelegatePin(): boolean {
        return this.pinCategory === PinCategory.delegate;
    }

    get isLinked(): boolean {
        return (this.linkedTo && this.linkedTo.length > 0);
    }
}

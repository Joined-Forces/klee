import { PinCategory } from "../data/pin/pin-category";
import { PinDirection } from "../data/pin/pin-direction";
import { PinLink } from "../data/pin/pin-link";
import { PinProperty } from "../data/pin/pin-property";
import { BlueprintParserUtils } from "./blueprint-parser-utils";
import { CustomPropertyParser } from "./custom-property.parser";

export class PinPropertyParser implements CustomPropertyParser {

    private _property: PinProperty;

    private readonly _propertyParsers: {
        [key: string]: (value: string) => void
    } = {
        "PinId": (value: string) => { this._property.id = value; },
        "PinName": (value: string) => { this._property.name = BlueprintParserUtils.parseString(value);  },
        "PinFriendlyName": (value: string) => { this._property.friendlyName = this.parsePinFriendlyName(value); },
        "PinType.PinCategory": (value: string) => { this._property.category = this.parsePinCategory(value); },
        "Direction": (value: string) => { this._property.direction = this.parseDirection(value); },
        "PinToolTip": (value: string) => { this._property.toolTip = BlueprintParserUtils.parseString(value); },
        "PinType.PinSubCategory": (value: string) => { this._property.subCategory = BlueprintParserUtils.parseString(value); },
        "PinType.PinSubCategoryObject": (value: string) => { this._property.subCategoryObject = this.parseSubCategoryObject(value); },
        "PinType.bIsReference": (value: string) => { this._property.isReference = value == "True"; },
        "PinType.bIsConst": (value: string) => { this._property.isConst = value == "True"; },
        "PinType.bIsWeakPointer": (value: string) => { this._property.isWeakPointer = value == "True"; },
        "PinType.bIsUObjectWrapper": (value: string) => { this._property.isUObjectWrapper = value == "True"; },
        "DefaultValue": (value: string) => { this._property.defaultValue = BlueprintParserUtils.parseString(value); },
        "AutogeneratedDefaultValue": (value: string) => { this._property.autogeneratedDefaultValue = BlueprintParserUtils.parseString(value); },
        "LinkedTo": (value: string) => { this._property.linkedTo = this.parseLinkedTo(value); },
        "bHidden": (value: string) => { this._property.hidden = (value === "True"); },
        "bDefaultValueIsIgnored": (value: string) => { this._property.defaultValueIsIgnored = (value === "True"); },
        "bDefaultValueIsReadOnly": (value: string) => { this._property.defaultValueIsReadOnly = (value === "True"); },
    }

    parse(propertyData: string): PinProperty {

        this._property = new PinProperty();
        let data = propertyData.split(/,(?![^(]*\))/g);

        for (let i = 0; i < data.length; ++i) {
            const keyValuePair = data[i].split('=');
            const key = keyValuePair[0];
            const value = keyValuePair[1];

            const parse = this._propertyParsers[key];
            if(!parse) {
                console.info(`Didn't parse property attribute ${key}. There isn't a matching parser.`);
                continue;
            }
            parse(value);
        }

        return this._property;
    }

    private parseLinkedTo(value: string): PinLink[] {
        let links = [];
        value = value.substr(1, value.length - 1);

        let data = value.split(',')
        for (let i = 0; i < data.length; ++i) {
            let dataset = data[i].split(' ');
            if (dataset.length == 2) {
                let link = new PinLink();
                link.nodeName = dataset[0];
                link.pinID = dataset[1];

                links.push(link);
            }
        }

        return links;
    }


    private parseSubCategoryObject(value: string): string {
        let obj = value;
        let matches = value.matchAll(/'"(.*)"'/g);
        if (matches) {
            let match = matches.next();

            if (match && match.value) {
                obj = match.value[1];
            }
        }

        return obj;
    }

    private parsePinFriendlyName(value: string): string {
        let name:string = "";

        if (value.startsWith("NSLOCTEXT")) {
            let prefixLength = 'NSLOCTEXT('.length - 1;
            value = value.substr(prefixLength, value.length - prefixLength - 1);

            let params = value.split(',');
            name = params[params.length - 1].replace(/"/g, '');
            return name;
        }

        name = value.replace(/"/g, '');

        return name;
    }

    private parsePinCategory(value: string): PinCategory {
        value = BlueprintParserUtils.parseString(value);
        switch (value) {
            case "exec": return PinCategory.exec;
            case "object": return PinCategory.object;
            case "int": return PinCategory.int;
            case "float": return PinCategory.float;
            case "struct": return PinCategory.struct;
            case "bool": return PinCategory.bool;
            case "delegate": return PinCategory.delegate;
            case "name": return PinCategory.name;
        }
    }

    private parseDirection(value: string): PinDirection {
        value = value.replace(/"/g, '');

        switch (value) {
            case "EGPD_Output": return PinDirection.EGPD_Output;
            case "EGPD_Input":
            default:
                return PinDirection.EGPD_Input;
        }
    }
}
